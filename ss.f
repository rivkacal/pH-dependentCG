
!* contains subrutines  start, stophere

!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
!* start creates reads the run settings from settings.dat, reads in the*
!* random variables for the random subroutine and creates output files.*
!***********************************************************************

      subroutine start

      include 'MD.com'

      character(1000) :: DynamicStr
      character(16) :: NeigFilename = 'neighbors.dat'
 
! (2000 * electron_charge^2 * avogadro constant) / (vacuum permitivity constant * boltzman constant )

      open(60, file = 'settings.dat', access ='sequential',
     Q status = 'old')

      read(60,*)
      read(60,*)
      read(60,*) startt ! indicates the format of the initial conditions
!      read(60,*) AN ! number of atoms in simulation
      read(60,*) Conf ! Conf is the input file generated by Read.f
      read(60,*) initval, finalpx1 ! initial coordinates,restart file
      read(60,*) output ! output information about simulation
      read(60,*) Trajectory, WOT ! Trajectory is the trajectory file name
                                 ! write out trajectory every WOT steps
	if(Trajectory .ne. 'NO')then
          open(6, FILE= Trajectory, access = 'SEQUENTIAL',
     Q    status = 'unknown')
          open(7, FILE= NeigFilename, access = 'SEQUENTIAL', 
     Q   status = 'unknown')
          read(60,*) TrajDist ! whether to store distances
	  if(TrajDist .ne. 'NO')then
            open(93, FILE= TrajDist, access = 'SEQUENTIAL',
     Q      status = 'unknown')
          end if
	endif

      read(60,*) EnergyTot, EnergyTerm ! These are the energy files
	if(EnergyTot .ne. 'NO')then
        open(99,file=EnergyTot,status='unknown',access='sequential')
	endif
        if(EnergyTerm .ne. 'NO')then
        open(70,file=EnergyTerm,status='unknown',access='sequential')
        endif

      read(60,*) ContactFile, ThreeBodyFile ! this stores the 
                                            ! contacts and 3 body contacts

        if(ContactFile .ne. 'NO')then
        open(12,file=ContactFile,status='unknown',access='sequential')
        endif
        if(ThreeBodyFile .ne. 'NO')then
        open(13,file=ThreeBodyFile,status='unknown',access='sequential')
        endif

	read(60,*) writeAllContacts
	if(writeAllContacts .eq. 'YES') then 
          read(60,*) allContactsFile
 	  open(14,file=allContactsFile,status='unknown',
     Q    access='sequential')
	endif
! check whether to write 2 Body & Elj for selected Contact Ranges
	read(60,*) writeContactsRanges
	if(writeContactsRanges .eq. 'YES') then 
          ! read the name of the contact ranges file 
	  read(60,*) ContactRangesFile	
	  ! open the output files 
	  read(60,*) ContactRangesTwoBodyFile
 	  open(15,file=ContactRangesTwoBodyFile,status='unknown',
     Q    access='sequential')
          read(60,*) ContactRangesEnergyFile
 	  open(16,file=ContactRangesEnergyFile,status='unknown',
     Q    access='sequential')
	endif	


      read(60,*) TemperatureVtime ! this is the temperature file

        if(TemperatureVtime .ne. 'NO')then
        open(58,file=TemperatureVtime,
     Q  status='unknown',access='sequential')
        endif

      read(60,*) symtype ! MD for Molecular Dynamics, LD for Langevin D.
      if(symtype .eq. 'LD')then
      read(60,*) gamma ! gamma is the drag coefficient
      endif
      read(60,*) stepstop, WO ! number of integration steps, write out
                                   ! measurements every WO steps, write out
                                   
      read(60,"(2F10.5)") tau, RsTau ! time step, coupling constant for Berendsen 
                            ! thermostat
      read(60,*) T ! temperature, in reduced units

      read(60,*) hasStaticAtoms ! whether to keep some atoms static
      if(hasStaticAtoms .eq. 'YES')then
       read(60,*) DynLength
       read(60,*) DynamicStr
       call genDynRange(DynLength,DynamicStr,DynamicAtomRange)
      endif

      read(60,*) confineInBox ! whether to confine the molecule in a box
      if(confineInBox .eq. 'YES')then
       read(60,*) boxMin(1),boxMin(2),boxMin(3) !minimum values for box
       read(60,*) boxMax(1),boxMax(2),boxMax(3) !maximum values for box
       read(60,*) boxCoeff !box force cofficient

      endif

      read(60,*) useElectrostatics !whether to apply coulombic interactions
      if(useElectrostatics .eq. 'YES')then
        read(60,*) deConstant !dielectric constant in epsilon 0 units
        read(60,*) esMinBeadDistance !dielectric constant in epsilon 0 units
        read(60,*) esCutoffType ! minimum energy to apply electrostatic force
	useESCutoff = 0
        if(esCutoffType .eq. 'ENERGY')then
          read(60,*) esEnergyCutoff ! minimum energy to apply electrostatic force
	  useESCutoff = 1
	endif
        if(esCutoffType .eq. 'DISTANCE')then
          read(60,*) esDistanceCutoff ! minimum energy to apply electrostatic force
          useESCutoff = 1
	endif
        read(60,*) compensateElectrostaticContacts ! minimum energy to apply electrostatic force
	read(60,*) useDebyeHuckel ! whether to use debye huckel screening factor
        if(useDebyeHuckel .eq. 'YES')then
          read(60,*) useDHEnergyTable
          if(useDHEnergyTable .eq. 'YES')then
	    useDHTable = 1
          else
	    useDHTable = 0
	  endif
          read(60,*) ionicStrength ! ionic strength of the solution
          read(60,*) ionicRadius ! the average radius of the ions in the solution (for example 1.4 for NaCl)
          read(60,*) solventDensity ! the specific density of the solvent (for example 1 for water)
        endif
	call initES
        if(useDHEnergyTable .eq. 'YES')then
          call dhenergytable(screeningFactor,saltCoefficient,
     Q deConstant,esDistanceCutoff,DebyeHuckelPotentials,
     Q DebyeHuckelForces)
	endif
      endif
       read(60,*) useChirals
       read(60,*) useEllipsoidRepulsions
       !read(60,*) 
        ! added by rivka to change the His charge during simulation
       read(60,*) pH ! pH of the solution
       read(60,*) changeHisCharge ! change charge
       if(changeHisCharge .eq. 'YES')then
          read(60,*) PROTCHARGEFREQ
          read(60,*) DEPROTCHARGEFREQ
       endif

      open(63, file = 'random.dat', access = 
     Q 'SEQUENTIAL',  status = 'UNKNOWN')
      read(63,*) xrandom,yrandom,zrandom
      close (63, status = 'KEEP')


	if(symtype  .eq. 'LD')then
	c_e = 1.0 - gamma*tau/2.0
	c_i = 1.0/(1+gamma*tau/2.0)
	endif

	writecount = 0
      end

!^^^^^^^^^^^^^^^^^^^^^^^^^^^end of start^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
!* stophere closes all files that are open.  It also stores            *
!* the new xrandom, yrandom and zrandom in file random.dat for use of  *
!* the random subroutine, next time this is run.                       *
!***********************************************************************

      subroutine stophere

      include 'MD.com'

! Close the files that holds the temperature

      close(71)

! this writes the new xrandom, yrandom and zrandom 
      open(63, file = 'random.dat', access = 
     Q 'SEQUENTIAL',  status = 'UNKNOWN')
      write(63,*) xrandom,yrandom,zrandom
      close (63, status = 'KEEP')

      return

      end

!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^end of stophere^^^^^^^^^^^^^^^^^^^^^^^^
 
      subroutine initES()
      include 'MD.com'
      
       real screeningFactorConstant,realTemperature, esCutoff

       real esEnergyError, esMinDistance, esMaxDistance, 
     Q     esCurrentDistance, esEnergy 

      parameter (screeningFactorConstant = 2529.11892) 

       if(useDebyeHuckel .eq. 'YES')then
! this supposedly transforms simulation temperature to real temperatures
         realTemperature = 295*T
! calculates the screening factor kappa
         screeningFactor = SQRT((screeningFactorConstant*
     Q   ionicStrength*solventDensity)
     Q   /(deConstant*realTemperature))
	 saltCoefficient = (exp(screeningFactor*ionicRadius)/
     Q   (1+screeningFactor*ionicRadius))
       endif
       
       if (esCutoffType .eq. 'ENERGY')then
         esMinDistance = 16.0
         esMaxDistance = 100000000.0

           if(useDebyeHuckel .eq. 'YES')then
	     call debyehuckelfactor(esMinDistance,deConstant,
     Q            screeningFactor,saltCoefficient,esEnergy)
           else
	     call coulombfactor(esMinDistance,deConstant,esEnergy)
           endif
         esCutoff = esEnergy * esEnergyCutoff
       
         esEnergyError = esCutoff / 100.0

         do i=1,5000
           esCurrentDistance = (esMaxDistance+esMinDistance)/2
           if(useDebyeHuckel .eq. 'YES')then
	     call debyehuckelfactor(esCurrentDistance,deConstant,
     Q            screeningFactor,saltCoefficient, esEnergy)
           else
	     call coulombfactor(esCurrentDistance,deConstant,
     Q                          esEnergy)
           endif
           	
	   ! esCutoff distance found
           if (abs(esCutoff-esEnergy) .le. esEnergyError)then
             esDistanceCutoff =  esCurrentDistance
             if (esDistanceCutoff .ge. esCutoffMax) then
               write(*,*) 
     Q         'distance Cutoff value exceeds maximum allowed'
               call abort
             end if             
             return 
           endif
           if(esEnergy .le. esCutoff)then
             esMaxDistance = esCurrentDistance
	   else
             esMinDistance = esCurrentDistance
           endif
         end do

         write(*,*) 'es cutoff distance not found'
         call abort
       end if

       if (esCutoffType .eq. 'DISTANCE')then
         if(esDistanceCutoff**2 .gt. esCutoffMax)then
            write(*,*) 
     Q     'distance Cutoff value exceeds maximum allowed'
           call abort
	 end if
	 esDistanceCutoff = esDistanceCutoff**2
       end if
      end
